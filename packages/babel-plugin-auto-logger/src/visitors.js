
import * as types from '@babel/types';

// services
import utils from './utils.js';
// constants
import consts from './constants.js';

/**
 * Visitors service
 *
 * @mixin
 */
const service = {};

/**
 * Program visitor. Will import logger service if we have source or it isn't already imported.
 *
 * @param {Object} path - node path
 * @param {Object} state - node state
 *
 * @return {undefined}
 */
service.program = (path, state) => {
  const validPathAndState = utils.isValidPathAndState(path, state);

  if (validPathAndState) {
    const loggerName = utils.getLoggerName(state);
    const isDefaultLoggerName = loggerName === consts.LOGGER_API;
    const loggerWasImported = Boolean(path.scope.bindings[loggerName]);

    if (!isDefaultLoggerName && !loggerWasImported) {
      // if we have custom logger AND logger was not imported
      //  => add import declaration
      path.unshiftContainer(
        'body',
        types.importDeclaration(
          [
            types.importDefaultSpecifier(
              types.identifier(loggerName)
            ),
          ],
          types.stringLiteral(utils.getLoggerSource(state))
        )
      );
    }
  }

};

/**
 * Visitor that will insert expression statement (will add logger calls based on path)
 * Logger is added only if:
 *  - the function was not generated by another plugin
 *  - the file matches the pattern for the source
 *  - the file does not match the pattern for the source exclusion
 *
 * @param {Object} path - node path
 * @param {Object} state - node state
 *
 * @return {undefined}
 */
service.insertExpressionStatement = (path, state) => {

  const validPathAndState = utils.isValidPathAndState(path, state);

  if (validPathAndState) {
    utils.addLogger(path, state);
  }

};

export default service;
